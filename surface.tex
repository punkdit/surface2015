%\documentclass[12pt,notitlepage,aps,pra,longbibliography,nofootinbib,tightenlines]{revtex4}
%\documentclass[12pt,notitlepage,longbibliography,nofootinbib,tightenlines]{revtex4-1}
%\documentclass[12pt,notitlepage,longbibliography,nofootinbib,tightenlines]{revtex4-1}

%\documentclass[12pt,a4]{revtex4}
\documentclass[12pt]{article}
%\documentclass[11pt, twocolumn]{article}


% xelatex:
\usepackage{fontspec}
\defaultfontfeatures{Ligatures=TeX}
%\usepackage[small,sf,bf]{titlesec}

%\setromanfont{DejaVu Serif}
%\setromanfont{Droid Serif}

%\setromanfont{Gentium} % nice! a bit fluffy
\setromanfont{Gentium Book Basic} % more bold

%\setromanfont{Noto Serif} % a bit thick
%\setromanfont{Utopia}


%\usepackage{epsf}
\usepackage{amsmath}
\usepackage{color}
\usepackage{natbib}
%\usepackage{cite}

\RequirePackage{amsmath}
\RequirePackage{amssymb}
\RequirePackage{amsthm}
%\RequirePackage{algorithmic}
%\RequirePackage{algorithm}
%\RequirePackage{theorem}
%\RequirePackage{eucal}
\RequirePackage{color}
\RequirePackage{url}
\RequirePackage{mdwlist}

\RequirePackage[all]{xy}
\CompileMatrices
\RequirePackage{hyperref}
\RequirePackage{graphicx}
%\RequirePackage[dvips]{geometry}


\makeatletter
\newcommand{\pushright}[1]{\ifmeasuring@#1\else\omit\hfill$\displaystyle#1$\fi\ignorespaces}
\newcommand{\pushleft}[1]{\ifmeasuring@#1\else\omit$\displaystyle#1$\hfill\fi\ignorespaces}
\makeatother


\begin{document}

%\title{The surface betrays what lies beneath}
%\title{Show me the morphism}
\title{When the surface betrays what lies beneath}

\author{Simon Burton}
%\affiliation{Centre for Engineered Quantum Systems, School of Physics, The University of Sydney}

\date{\today}

%\begin{abstract}
%We make a compendium of many uses of a simple idea.
%Perhaps it is the only really great calculation.
%\end{abstract}

\maketitle


\def\Z{\mathbb Z}
\def\R{\mathbb R}
\def\Complex{\mathbb{C}}
\def\GL{\mathrm{GL}}
\def\half{\frac{1}{2}}
\def\todo#1{\emph{(XXX #1 XXX)}}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%

%\section{Introduction}

The so-called ``Generalized Distributive Law''
\cite{Aji2000}
explores the ramifications of the innocent looking
formula $ab+ac = a(b+c).$
These include such gems as the fast Fourier transform
and belief propagation.
We can also think of multiplication by $a$ as a function $f$
and rewrite this equation as 
$$
    f(b)\hat{+}f(c)=f(b+c) \ \ \ \ \ \ \ \ \ \ \ \mbox{(M)}
$$
This is the equation for a homomorphism, or representation.
It says we can represent addition (on the right-hand side)
as some other kind of addition, $\hat{+}.$
%The simple distributive law states that we can zoom in or out

A technique that shows up in various places:
mathematics, physics, computer science, statistics..

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%

\section{Fast Fourier transform}

% Apparently invented by Gauss:
% http://www.cis.rit.edu/class/simg716/Gauss_History_FFT.pdf


%The discrete Fourier transform of a sequence $\{x_j\}_0^{N-1}$
%is given by
%$$
%%    y_k = \sum_{j=0}^{N-1} x_j e^{2\pi i k \frac{j}{N}}, \ \ k=0,...,N-1.
%    y_k = \sum_{j=0}^{N-1} x_j \omega^{kj}, \ \ k=0,...,N-1.
%$$
%where $\omega=e^{2\pi i/N}.$
%If $N$ is a composite number $N=N_1 N_2$ then we can re-express this sum as
%\begin{align*}
%    y_k &= \sum_{j_1=0}^{N_1-1} \sum_{j_2=0}^{N_2-1} x_{j_1 N_2 + j_2}
%            \omega^{k (j_1 N_2 + j_2)}, \ \ k=0,...,N-1. \\
%        &= \sum_{j_1=0}^{N_1-1}
%            \omega^{k {j_1 N_2}}
%            \sum_{j_2=0}^{N_2-1} x_{j_1 N_2 + j_2}
%            \omega^{k {j_2}}, \ \ k=0,...,N-1.
%\end{align*}
The discrete Fourier transform of a function $f:\Z_n\to \R$
is another function $\hat{f}:\Z_n\to \R$ given by
$$
    \hat{f}(k) := \sum_{j=0}^{n-1} \omega^{jk}f(j),%\ \ \ \mathrm{with}\ \ \omega:=e^{\frac{2\ph i}{n}}.
$$
where $\omega=e^{2\pi i/n}.$
If $n$ is a composite number $n=pq$ then we
write $j=j_1 q + j_2$ with $j_1 = 0,...,p-1$ and $j_2 = 0,...,q-1$
and also $f(j_1, j_2):=f(j_1 q + j_2)$
then
\begin{align*}
        \hat{f}(k) = \sum_{j_2=0}^{q-1} \omega^{j_2k} \sum_{j_1=0}^{p-1} \omega^{j_1kq} f(j_1,j_2) 
\end{align*}
If we rewrite $k$ using
$k=k_1 q + k_2$ with $k_1 = 0,...,p-1$ and $k_2 = 0,...,q-1$
and note that 
$\omega^{j_1kq}=\omega^{j_1(k_2p+k_1)q}=\omega^{j_1k_1q}:$
$$
        \hat{f}(k_1, k_2) = \sum_{j_2=0}^{q-1} \omega^{j_2(k_2 p+k_1)} \sum_{j_1=0}^{p-1} \omega^{j_1k_1q} f(j_1,j_2)
$$
The point here is that the inner sum does not depend on $k_2:$
\begin{align*}
        \hat{f}(k_1, k_2) &= \sum_{j_2=0}^{q-1} \omega^{j_2(k_2 p+k_1)} g(k_1, j_2) \\
        &\ \ \mathrm{with} \ \ g(k_1,j_2) := \sum_{j_1=0}^{p-1} \omega^{j_1k_1q} f(j_1,j_2)
\end{align*}
so we can re-use the calculation of $g(k_1, j_2)$ 
in each of the terms $\hat{f}(k_1, k_2)$ for $k_2=0,...,q-1.$


%Displaying this graphically. Bratelli diagram, butterfly network

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%

\section{Belief propagation}

Economics

Bethe Anatz (solves Heisenberg in 1D), cavity method.
Is there a forward \& reverse?

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%

\section{Dijkstra's algorithm}

Let $G$ be a finite graph: $G = (V, E).$
%Choose a POSET $\P$ with unique 
For $x,y\in V$ Write $x\sim y$ when there
is an edge between $x$ and $y.$ % or when $x=y.$
%Let $\P=\mathbb Z \cup \{\infty\}$ be the ordered set of integers with a top element.
Define the set of \emph{states} as %``height'' functions
the finite dimensional vector space
$A = \{ f | f : V \to \R \}.$

The \emph{message passing} function
$T:A\to A$ is defined by
$$(Tf)(x) = \min\{f(x), \min_{y\sim x} f(y)+1\}.$$

{\bf Lemma.} There exists $n$ such that $T^{n+1} = T^n.$

{\bf Proof.}
%$A$ is a partially ordered set, using
%the pointwise order:
%$f\le g$ iff $f(x)\le g(x)\ \forall x\in V.$
%$T$ is monotonic non-increasing on $A.$
%For any $f\in A$ we have $g\le f$
%where $g$ is a constant function defined by $g(x)=\min_y f(y).$
%Therefore the set $\{f, Tf, T^2f,...\}$ is finite.
%\todo{Insert elegant proof here. Need to use $G$ finite.}
%The proof is by induction.
This is Dijkstra's algorithm \cite{Dijkstra1959}.
Without loss of generality we may take
$G$ to be connected.
Choose $f\in A.$
Define $f_i = T^i f.$
%We will show that $T^{n+1}f = T^n f$
We will show that $f_{n+1} = f_n$
where $n$ depends only on $G.$
%we will partition the vertices $V$ into three sets:
For each iteration, $i=1,...,n$
we will maintain a subset $S_i\subset V$
of ``accepted'' vertices:
if $x\in S_i$ then $f_i(y)-f_i(x)\le 1$ for all $y\sim x.$
Begin with $S_1=\arg\min(f).$
Then at each step we expand $S_i$ using its
neighbourhood: $S_{i+1}=S_i\cup \partial S_i.$
If we choose $n=|V|$ then $S_n=V$ and we are done.
\qed

%Let $n$ be the minimum $n$ such that $T^{n+1}=T^n.$ 

\def\Fix{\mathrm{Fix}}

%Any $f\in  A$ such that $Tf=f$ is called \emph{stationary.}
%The set of such states we denote $\Fix(T).$
The set of fixed points of $T$ we denote as
$\Fix(T):=\{f\in A|Tf=f\}.$
%Any constant function  is stationary.
%The functions furthest away from being stationary
%are the $f$ that have $T^nf\ne T^{n-1}f.$
%We call these the \emph{points} of $T.$
%We would like to identify these functions with
%the vertices of the graph, but there are too many such $f$.
It can be seen that
a state $f$ is fixed by $T$ iff
$f(x)\le f(y)+1,\ \forall x\sim y.$
Direct computation shows that
%set of stationary states is convex:
$\Fix(T)$ is convex:
given $f$ and $g$ both fixed by $T$,
and $\alpha\in[0, 1]$ then $\alpha f + (1-\alpha) g$
is fixed by $T$.

We declare two states $f$ and $g$
to be equivelant whenever $f-g$ is a constant function.
%We define an equivalence relation on 
%states $f$ and $g$ by 
%declaring $f\sim g$ when $f-g$ is a constant state. 
This equivalence relation defines a projection $P,$
and $P(\Fix(T))$ is now a compact convex subset of
a finite dimensional real vector space.
\todo{looks like $A$ could be defined as affine ?}
Furthermore, this set is the intersection
of a finite set of closed half-spaces and
so has finitely many extreme points.
For each edge $x\sim y$ of the graph
we get a closed half space
$f(x)\le f(y)+1.$
This half space survives the action of $P$
because we can rewrite it as $f(x)-f(y)\le 1.$

For each extreme point $f$ of $P(\Fix(T))$ 
we will associate a directed graph $D_f$
as follows.
$D_f$ has the same vertex set as $G$.
$f$ will saturate a set of inequalities,
$f(x)-f(y)=1$
and this gives a directed edge $y\to x$ in $D_f.$
%This set must touch every vertex of $G.$
Every vertex participates in at least one
directed edge.
A \emph{path} in $D$ is a directed sequence of edges.
There are no loops (closed paths) in $D$.

{\bf Theorem.} Every $D$ path from $x$ to $y$ has
minimal length among all paths in $G$ from $x$ to $y.$

Conversely, to find a path of minimal length 
from $x$ to $y$ we set $f$ to be the ``indicator''
function for $x$ and then $T^nf$ will correspond
to an extremal point of $P(Fix(T))$ whose directed
graph contains all paths from $x$ to $y$ of minimal length in $G.$
The \emph{indicator} function for \ $x\in V$ \ is \ $\delta_x:V\to \R$ 
\ defined as\ $\delta_x(x)=0$\ and\ $\delta_x(y)=\mathrm{width}(G)$
\ for\ $y\ne x.$

Question: count the number of directed spanning trees in an undirected graph.
% Combinatorial species

\emph{Alternative formulation:}
a vector in a graph $G=(V,E)$ is a vertex, edge pair $(v,e)$ with $v\in e.$
The tangent space at a vertex $v$ is the set of all vectors $(v,e)$
at $v$.
Tanget vectors act on $A$...
Extremal points of $P(Fix(T))$ give discrete morse function...
what are the critical points?
Critical vertices are leaves, critical edges are those that cause loops... (check...)


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%

\section{Dynamic programming}

Linear programming, simplex method (duality)

Approximate Dynamic programming (Reinforcement learning)
% https://webdocs.cs.ualberta.ca/~bowling/papers/07adprl-dualrl.pdf

Eikonal equation

Bellman's equation ---> Hamilton-Jacobi equations ---> Schrodinger (wave) Equation

% Recursive domain equations
% Combinatorial species (monads?)

Maximising buying and selling a price function $f:[0,1]\to \R$:
    The solution is to buy the local minima and sell the
    local maxima. Can get this via a test function and
    integration by parts. This is a morse function, with
    critical points being the trades.
    Is this also the dynamic programming solution?

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%

\section{Huygen's principle}

Path integrals, calculus of variations

Integration by parts involves a crucial use of the distributive law.

Stoke's theorem ? % Chern-Simons ? AdS-CFT correspondence ?

Green's function...?

% Wave equation, Elliptic PDE's, Sobolev spaces...??? Elliptic PDE's represent
% static sollutions (eg. laplace/poisson equation)..

\section{Representing Compact Hausdorff spaces}


There is a vast theory of representing topological spaces as
algebraic objects, here we present one of the simplest such
instances of this
\cite{Nagata1985}.

%https://books.google.com.au/books?id=DMLSBQAAQBAJ&pg=PA132&lpg=PA132&dq=compact+space+%22lattice+of+continuous+functions%22&source=bl&ots=t5g-GKJjma&sig=xfFhgg3SPhR72Xy9fONk_I3fZxQ&hl=en&sa=X&ved=0ahUKEwjK3OL2rpnKAhUG5KYKHVhvBDUQ6AEIQDAF#v=onepage&q=compact%20space%20%22lattice%20of%20continuous%20functions%22&f=false

Let $X$ be a compact Hausdorff space.
Let $C(X)$ be the set of real valued continuous functions on $X$.
%This is a ring under pointwise addition and multiplication.
This is a lattice under the pointwise meet and join operations inherited from $\R$.

A \emph{prime ideal} of $C(X)$ is $\{x\in X:f(x)=0\}$ where $f:X\to \{0,1\}$
is any lattice homomorphism.

{\bf Lemma.} A proper subset $J$ of $C(X)$ is a prime ideal
iff it satisfies the following:\newline
\ \ \ (1) $f\in J$ and $g\in J$ implies $f\vee g \in J,$ \newline
\ \ \ (2) $f\in J$ and $g<f$ implies $g\in J,$ \newline
\ \ \ (3) $f\notin J$ and $g\notin J$ implies $f\wedge g\notin J.$
\qed

We can associate points $x\in X$ to prime ideals $P$ as follows:
if $f\in P$ and $g(x)< f(x)$ then $g\in P.$

Given a point $x\in X$ we can build a prime ideal associated to $x$
as $\{f\in C(X) | f(x)<a\}$ where $a$ is any constant in $\R.$

{\bf Lemma.} Any prime ideal $P$ is associated with exactly one point $x\in X.$
\qed

To make the association one-to-one we
define an equivelance relation on prime ideals:
$P_1\sim P_2$ when $P_1\cap P_2$ contains a prime ideal.

{\bf Lemma.} Two prime ideals $P_1$ and $P_2$ are associated with the same
point iff $P_1\sim P_2.$
\qed

The collection of isomorphism classes of prime ideals we denote $\Delta(X).$
We also write $\Delta(x)$ for the isomorphism class associated with $x\in X.$
These will be the points of a topological space, whose topology we
define using the following closure operation.
Let $B\subset\Delta(X)$ and $q\in\Delta(X).$
Then $q\in\bar{B}$ iff 
for each $q'\in B$
we can choose a prime ideal $P(q')$ such that
$\cap_{q'\in B} P(q')$ is non-empty and contained in some other prime ideal $P\in q.$

%{\bf Lemma.} This closure operation defined on subsets of $\Delta(X)$ is the
%same as the closure operation on $X$ 
{\bf Lemma.} Let $A\subset X$ and $x\in X$. Then $x\in\bar{A}$ iff
$\Delta(x)\in\overline{\Delta(a)}$ in $\Delta(X).$
\qed

This shows that $\Delta(X)$ is homeomorphic to the original space $X.$
Furthermore, since the space $\Delta(X)$
was defined using only the lattice operations of $C(X)$ we have that
any two compact Hausdorff spaces $X$ and $Y$ are homeomorphic iff $C(X)$ and
$C(Y)$ are isomorphic as lattices.

% Notice: these prime ideals look alot like Green's functions, or
% the ``seed'' functions used to drive Dijkstra's algorithm.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%

\section{Automatic differentiation}

forward and reverse

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%

\section{Logic: cut-elimination}

Natural deduction, Gentzen's sequent calculus..

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%

\section{Combinatorics...}

path counting, transfer matrix...
generating functions? 
creation/annihilation operators?
denotational semantics?

zippers and differentiating data structures

% Unitary evolution is "immutabile" evolution of quantum state... 
% Can we use zippers to define a kind of measurement process?


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%

\section{Renormalization?}

works in 1d... dual is zoom-in ?

\section{Homology/Co-Homology?}

Forward and reverse

%\section{Type inference?}
%
% Haskell can infer the result type of a function from its argument (forward), or the argument type from the result (backward)

% Gaussian elimination? Euclids algorithm? Buchberger's algorithm?

% Membrane computing ?


\bibliography{refs}{}
\bibliographystyle{abbrv}


\end{document}


